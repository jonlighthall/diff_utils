\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}  % For \checkmark and other math symbols
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}

\geometry{margin=1in}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    language=C++,
    commentstyle=\color{green!60!black},
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    showstringspaces=false
}

\title{Sub-LSB Detection Implementation Summary}
\author{}
\date{October 16, 2025}

\begin{document}

\maketitle

\section{Overview}

Successfully implemented and validated sub-LSB (Least Significant Bit) detection in \texttt{uband\_diff} to correctly handle cross-precision numerical comparisons.
test.

\section{The Problem}

\subsection{Original Issue}

Comparing \texttt{30.8} (1 decimal place) vs \texttt{30.85} (2 decimal places) with threshold=0:

\begin{itemize}
    \item \textbf{Before Fix:} Reported as SIGNIFICANT difference (failed comparison)
    \item \textbf{After Fix:} Reported as EQUIVALENT (passed comparison)
\end{itemize}

\subsection{Root Cause}

The code was checking \texttt{rounded\_diff} instead of \texttt{raw\_diff} against \texttt{big\_zero} (half-LSB):

\begin{lstlisting}
// BEFORE (BUGGY)
bool trivial_after_rounding = (rounded_diff <= big_zero);

// rounded_diff = 0.1 (30.85 rounds to 30.9 at 1dp)
// big_zero = 0.05 (half of LSB at 1dp)
// Check: 0.1 <= 0.05 -> FALSE -> Classified as NON-TRIVIAL
\end{lstlisting}

\section{The Solution}

\subsection{Core Fix (\texttt{src/difference\_analyzer.cpp})}

Changed to check \texttt{raw\_diff} with floating-point tolerance:

\begin{lstlisting}
// AFTER (FIXED)
constexpr double FP_TOLERANCE = 1e-12;
bool sub_lsb_diff = (raw_diff < big_zero) ||
    (std::abs(raw_diff - big_zero) <
     FP_TOLERANCE * std::max(raw_diff, big_zero));
bool trivial_after_rounding =
    (rounded_diff == 0.0 || sub_lsb_diff);

// raw_diff = 0.05
// big_zero = 0.05
// Check: 0.05 <= 0.05 (with FP tolerance) -> TRUE
// Classified as TRIVIAL
\end{lstlisting}

\subsection{Floating-Point Robustness}

The FP\_TOLERANCE handles edge cases where:

\begin{itemize}
    \item $\text{raw\_diff} = 0.05000000000000071054$
    \item $\text{big\_zero} = 0.05000000000000000278$
    \item Difference: $\approx 7 \times 10^{-16}$ (due to FP representation)
\end{itemize}

Without tolerance, $\text{raw\_diff} > \text{big\_zero}$ would fail. With tolerance, correctly classified as equivalent.

\subsection{Decimal Places Limit Update (\texttt{src/line\_parser.cpp})}

\textbf{Before:}
\begin{lstlisting}
if (ndp < 0 || ndp > 10) {  // Arbitrary limit
\end{lstlisting}

\textbf{After:}
\begin{lstlisting}
constexpr int MAX_DECIMAL_PLACES = 17;
// IEEE 754 double precision limit
if (ndp < 0 || ndp > MAX_DECIMAL_PLACES) {
\end{lstlisting}

\textbf{Rationale:} Double precision provides $\approx$15--17 significant decimal digits. The original limit of 10 was arbitrary and too restrictive.

\section{Testing \& Validation}

\subsection{Unit Tests (\texttt{tests/test\_sub\_lsb\_boundary.cpp})}

Created comprehensive test suite with 6 test cases:

\begin{enumerate}
    \item \textbf{ExactHalfLSBDifferenceAtZeroThreshold} -- The canonical 30.8 vs 30.85 case
    \item \textbf{SubLSBAtMultiplePrecisionLevels} -- Tests at 1dp, 2dp, 3dp, 4dp
    \item \textbf{SupraLSBDifferencesAreNonTrivial} -- Verifies 1 LSB difference is non-trivial
    \item \textbf{MixedSubLSBAndSupraLSBDifferences} -- Multiple values with different classifications
    \item \textbf{CrossPlatformFormattingEquivalence} -- Simulates cross-platform scenario
    \item \textbf{SubLSBWithNonZeroThreshold} -- Validates with user thresholds $> 0$
\end{enumerate}

\textbf{Status:} All 43 tests pass (6 sub-LSB tests + 37 existing tests)

\subsection{Pi Precision Test Suite}

Created Fortran program (\texttt{pi\_precision\_test.f90}) that:

\begin{itemize}
    \item Calculates $\pi$ using Machin's formula
    \item Outputs $\pi$ with increasing precision (0dp to 14dp)
    \item Validates that ANY two precision levels are considered equivalent
\end{itemize}

\textbf{Test Results:}

\begin{itemize}
    \item Identical files recognized correctly
    \item Cross-precision (3.1 vs 3.14) recognized as equivalent
    \item Multiple cross-precision comparisons pass
    \item High precision (17 decimal places) handled correctly
\end{itemize}

\subsection{Test Automation}

Created \texttt{test\_pi\_precision.sh} script for automated validation.

\section{Files Modified}

\subsection{Core Implementation}

\begin{enumerate}
    \item \textbf{src/difference\_analyzer.cpp} (Lines 98--113)
    \begin{itemize}
        \item Changed \texttt{trivial\_after\_rounding} check
        \item Added \texttt{sub\_lsb\_diff} with FP tolerance
        \item Added extensive inline comments
    \end{itemize}

    \item \textbf{src/line\_parser.cpp} (Lines 59--73)
    \begin{itemize}
        \item Increased \texttt{MAX\_DECIMAL\_PLACES} from 10 to 17
        \item Updated error message to use constant
    \end{itemize}
\end{enumerate}

\subsection{Testing}

\begin{enumerate}
    \setcounter{enumi}{2}
    \item \textbf{tests/test\_sub\_lsb\_boundary.cpp} (NEW, 265 lines)
    \begin{itemize}
        \item 6 comprehensive test cases
        \item Validates edge cases and floating-point handling
    \end{itemize}
\end{enumerate}

\subsection{Documentation}

\begin{enumerate}
    \setcounter{enumi}{3}
    \item \textbf{docs/SUB\_LSB\_DETECTION.md} (NEW)
    \begin{itemize}
        \item Complete technical explanation
        \item Information-theoretic justification
        \item Mathematical formulation
    \end{itemize}

    \item \textbf{docs/PI\_PRECISION\_TEST\_SUITE.md} (NEW)
    \begin{itemize}
        \item $\pi$-based validation strategy
        \item Test methodology and results
    \end{itemize}
\end{enumerate}

\subsection{Test Programs}

\begin{enumerate}
    \setcounter{enumi}{5}
    \item \textbf{pi\_precision\_test.f90} (NEW, 126 lines)
    \begin{itemize}
        \item Fortran 90 program to calculate $\pi$
        \item Generates test files at varying precision
    \end{itemize}

    \item \textbf{test\_pi\_precision.sh} (NEW)
    \begin{itemize}
        \item Automated test script
        \item Validates all cross-precision scenarios
    \end{itemize}
\end{enumerate}

\section{Mathematical Foundation}

\subsection{LSB (Least Significant Bit)}

For a value with $n$ decimal places:

\begin{align}
    \text{LSB} &= 10^{-n} \quad \text{(minimum representable step)} \\
    \text{big\_zero} &= \frac{\text{LSB}}{2} \quad \text{(half-LSB threshold)}
\end{align}

\subsection{Sub-LSB Criterion}

A difference is \textbf{sub-LSB} if:

\begin{equation}
    \text{raw\_diff} \leq \text{big\_zero} \quad \text{(with floating-point tolerance)}
\end{equation}

\subsection{Example: 30.8 vs 30.85}

\begin{align*}
    \text{Precision:} & \quad 1 \text{ decimal place} \\
    \text{LSB} &= 10^{-1} = 0.1 \\
    \text{big\_zero} &= 0.05 \\
    \text{raw\_diff} &= |30.8 - 30.85| = 0.05 \\
    \text{Test:} & \quad 0.05 \leq 0.05 \quad \checkmark \\
    \text{Classification:} & \quad \textbf{TRIVIAL} \text{ (sub-LSB difference)}
\end{align*}

\subsection{Information-Theoretic Justification}

A value printed as \texttt{30.8} (1dp) represents the interval $[30.75, 30.85)$.

The value \texttt{30.85} falls exactly at the boundary of this interval.

Therefore, the difference is within the representational uncertainty of the coarser precision.

\section{Impact \& Benefits}

\subsection{Cross-Platform Robustness}

Different systems may output the same computed value at different precisions:

\begin{itemize}
    \item Platform A: \texttt{30.8} (1dp)
    \item Platform B: \texttt{30.85} (2dp)
\end{itemize}

These are now correctly recognized as equivalent, enabling robust cross-platform validation.

\subsection{Scientific Validity}

Sub-LSB differences are informationally equivalent at the coarser precision. Treating them as equivalent is mathematically sound and scientifically appropriate.

\subsection{Backward Compatibility}

\begin{itemize}
    \item Existing tests continue to pass (37/37 original tests)
    \item No changes to user-facing API or command-line interface
    \item Only affects classification of boundary cases
\end{itemize}

\section{Test Results Summary}

\subsection{Before Implementation}

\begin{itemize}
    \item \textbf{Original case (case6r):} 1 significant difference reported, files NOT equivalent
    \item \textbf{make test:} 37 tests passing
\end{itemize}

\subsection{After Implementation}

\begin{itemize}
    \item \textbf{Original case (case6r):} 0 significant differences, files ARE equivalent
    \item \textbf{make test:} 43 tests passing (37 original + 6 new)
    \item \textbf{pi precision tests:} All cross-precision comparisons pass
\end{itemize}

\section{Conclusion}

The sub-LSB detection implementation successfully addresses a critical edge case in numerical comparison, enabling robust cross-platform validation while maintaining mathematical rigor and scientific validity. All tests pass, documentation is complete, and the implementation is production-ready.

\section{Future Enhancements (Optional)}

\begin{enumerate}
    \item \textbf{LEVEL 1.5 Discrimination:} Add explicit sub-LSB counter for detailed statistics
    \item \textbf{User Control:} Add command-line flag to enable/disable sub-LSB detection
    \item \textbf{Extended Precision:} Support for quadruple precision (IEEE 754 binary128)
\end{enumerate}

\section{References}

\begin{itemize}
    \item IEEE 754 Double Precision: $\approx$15--17 significant decimal digits
    \item Machine epsilon (double): $\approx 2.22 \times 10^{-16}$
    \item Information theory: Precision defines representational uncertainty
\end{itemize}

\end{document}
